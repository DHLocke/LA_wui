---
title: "03_descriptives_EDA"
author: "Dexter H. Locke, PhD"
date: "`r format(Sys.time())`"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This assumes "02_Woosley_combine_data.Rmd" was run


## 0 set up: load libraries, custom functions, set defaults
```{r}
# load libraries
# packages we'll be using
packs <- c('tidyverse'        # a must have!
           # , 'tidylog'        # makes things very verbose for 2x checking 
           # , 'magrittr'       # all of the pipes
            , 'janitor'        # cleans things up
           # , 'sf'             # simple features
           # , 'mapview'        # quick webmaps for zoom/pan viz
           , 'gtsummary'      # for descriptive table
           , 'patchwork'         #to combine ggplots
           # #'tidycensus',     # access to Census data in a tidy way 
           # #'party',          # random forests
           # , 'dataMaid'       # nice reports
           # , 'patchwork'      # combine ggplot graphics
           # , 'tictoc'         # times things
           # , 'beepr'          # makes noises
           # , 'psych'          # describe is very useful for descriptive statistics
           # , 'sjPlot'
           # ,'sciplot')        # useful plotting and regression support
)
# check for all of the libraries
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packs, rownames(installed.packages())))  
}

lapply(packs, library, character.only = TRUE)


# changing from tidyr v0.8.3 -> v1.0.0 broke things for nest and unnest!
# https://tidyr.tidyverse.org/articles/in-packages.html#tidyr-v0-8-3---v1-0-0
library(tidyr)
nest <- nest_legacy                     # Why Hadley, WHY!
unnest <- unnest_legacy


# set custom function for getting spatial data
see_sf <- function(){
# what's in memory that are sf - spatial features?
keep(eapply(.GlobalEnv, class),      # gets the objects in the global environment
     ~ any(str_detect(., "sf"))) %>% # selects elements with sf in them
names(.) %>% as.character(.)       # my simple features
}

see_sf() -> sf_in_memory

## what are the spatial references of those SF classes?
mget(sf_in_memory) %>%
purrr::map(~st_crs(.x)$epsg) %>% unlist() #%>% View()

# NOT IN
`%nin%` <- Negate(`%in%`) # custom function

# where are we?
list.files()
list.files('data')

# parameter to keep in general, for later..
pxl_to_ft_conversion <- 0.75
# pxl_to_ft_conversion <- 0.2286004572

set.seed(19870630)

## Make a 'figures' subdirectory if one doesn't exist
# ifelse(!dir.exists(file.path('figures')), dir.create(file.path('figures')), FALSE)
```


## 1 read in the data
```{r}
# build <- read_csv(paste0(getwd(), '/output_data/building_2021-04-07.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2021-04-15.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2021-04-23.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2021-04-26.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2021-09-27.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2021-10-05.csv')) %>% glimpse
#build <- read_csv(paste0(getwd(), '/output_data/building_2021-11-03.csv')) %>% glimpse
#build <- read_csv(paste0(getwd(), '/output_data/building_2021-12-02.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2021-12-22.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2022-02-01.csv')) %>% glimpse
# build <- read_csv(paste0(getwd(), '/output_data/building_2022-02-01.csv')) %>% glimpse



# one 'main' data frame
build <- read_csv(paste0(getwd(), '/output_data/building_2022-06-10.csv')) %>%
  tidylog::select(
    ID_Build
    # damage_binary
    , damage_cat         # binary outcome encoded as categorical (Destroyed / Survived)
    , damage_severity    # five levels
    , build_area   
    # build_DECKPORCHE    , #drop this on 12/20/21
    , build_DECKPORCHO
    , build_EAVES
    , build_EXTERIORSI
    , build_FENCEATTAC
    , build_PATIOCOVER
    , build_PROPANETAN
    , build_ROOFCONSTR
    , build_VEGCLEARAN 
    , build_VENTSCREEN 
    , build_WINDOWPANE 
    , parcel_year_built 
    , build_near_build 
    , build_has_tree_overhang 
    , build_min_dist_shrub 
    , build_min_dist_tree 
    , build_overhang_ht 
    , build_perc_overhang 
    , parcel_Build_P 
    , parcel_Can_P 
    , parcel_Grass_P 
    #, parcel_Imperv_P    #inverse of perv surface; shld we just drop bc we don't have for other measures?
    , parcel_Paved_P    
    #  parcel_Perv_P    ,#inverse of imp, just need one
    , parcel_Road_P
    , parcel_Shrub_P  
    , parcel_Soil_P  
    , parcel_Water_P  
    , build_near_dest  
    , build_p_building_10  
    , build_p_building_100  
    , build_p_building_200  
    , build_p_building_300  
    , build_p_grass_10  
    , build_p_grass_100  
    , build_p_grass_200  
    , build_p_grass_300  
    , build_p_otherpaved_10  
    , build_p_otherpaved_100  
    , build_p_otherpaved_200  
    , build_p_otherpaved_300  
    , build_p_road_10  
    , build_p_road_100  
    , build_p_road_200  
    , build_p_road_300  
    , build_p_shrub_10  
    , build_p_shrub_100  
    , build_p_shrub_200  
    , build_p_shrub_300  
    , build_p_soil_10  
    , build_p_soil_100  
    , build_p_soil_200  
    , build_p_soil_300  
    , build_p_tree_10  
    , build_p_tree_100  
    , build_p_tree_200  
    , build_p_tree_300  
    , build_p_water_10  
    , build_p_water_100  
    , build_p_water_200  
    , build_p_water_300  
    , parcel_area  
    , build_Mean_builddens  
    , build_Mean_distall_road  
    , build_Mean_distroad  
    , build_Mean_aspect_100m_DEM  
    , build_Mean_aspect_30m_DEM  
    , build_Mean_elev_100m  
    , build_Mean_elev_30m  
    , build_Mean_slope_100m_DEM  
    , build_Mean_slope_30m_DEM
    , build_DINS
    ) %>%
  mutate_if(is.character, as.factor) %>% # turns characters into factors
  droplevels() %>% 
  data.frame() # some of the random forest functions do not 'like' tibbles
               # since the non-dins and dins data will be pulled from here
               # we change here so that the subsets are already formatted as data.frames


 
```




## 2 descriptive statistics & Table for pub
```{r eval=FALSE, include=FALSE}

#summary information for paper text
length(unique(build$parcel_area)) #size of parcel areas as a measure for unique parcels

tabyl(build$build_has_tree_overhang) # 71.05% of buildings have tree overhang

build %>% 
  filter(build_has_tree_overhang==0) %>%
  tabyl(build_min_dist_tree) #when a building does NOT have tree overhang, 40% of the time it is still touching tree (0.75 appears to be min as of 7/11/22)

build %>% 
  filter(build_has_tree_overhang==0) %>%
      summary() #when a building does NOT have tree overhang, it is a median of less than 2 ft from tree cover (0.75 appears to be min as of 7/11/22)

#building size by destroyed
build %>% 
  group_by(damage_cat) %>%     # group data by damage_cat
  summarise(                                                          
    build_n       = n(),         # number of rows per group
    min_size   = min(build_area),   #min
    max_size   = max(build_area) , #max
    mean_size = mean(build_area)  ,#mean
    median_size = median (build_area) #median
  )
  

#distance to building
build %>% 
  group_by(damage_cat) %>%     # group data by damage_cat
  summarise(                                                          
    build_n       = n(),         # number of rows per group
    mean_anybldg = mean(build_near_build)  ,#mean
    median_anybldg = median (build_near_build), #median
    mean_burnbldg = mean(build_near_dest)  ,#mean
    median_burnbldg = median (build_near_dest) #median
  )
  


#damage cat and parcel_Build_P
build %>% 
  group_by(damage_cat) %>%     # group data by damage_cat
  summarise(                                                          
    build_n       = n(),         # number of rows per group
    min   = min(parcel_Build_P),   #min
    max    = max(parcel_Build_P) , #max
    mean  = mean(parcel_Build_P)  ,#mean
    median  = median (parcel_Build_P) #median
  )

 

#DINS has 12% survived only
table(build$damage_cat,build$build_DINS)
# generates report of univariate distributions with added info
system.time(makeDataReport(build, file = paste0(getwd(), '/output_data/dataMaid_',
                                    gsub('[[:punct:]]', '_', Sys.time()), '.Rmd')))


# univariate descriptions
build %>% 
  #tidylog::select_if(is_double) %>% 
  describe %>% 
  data.frame() %>% 
  rownames_to_column(var = 'variable_name') %>% 
  rename(variable_number = vars)  %>% 
  # write_csv(., paste0(getwd(), '/output_data/describe_',
  #                   gsub('[[:punct:]]', '_', Sys.time()), '.csv'))

# Remember re sample size w RF, we should include parcel_year_built and build_Mean_distroad 
#some additional descriptive information/summaries
length(unique(build$ID_Parcel)) #number of unique parcels
table(build$damage_cat)
table(build$build_structures_DAMAGE)
table(build$build_PROPANETAN)

#DINS has 12% survived only
table(build$damage_binary,build$build_DINS)

#type of parcel, 9983 were residential
table(build$parcel_UseType)
#homeowner occupied
table(build$parcel_Roll_HomeOwnersExemp); #5600 or 7000 indicates homeowner occupied - see https://www.titleadvantage.com/mdocs/Homeowners%20prop%20tax%20exemption%20all.pdf
table(build$parcel_UseType,build$parcel_Roll_HomeOwnersExemp) #Among residential, Residential 44.3% are owner occupied, and 54.9% renter occupied
  
# # confirming it's ok to have low values for build_perc_overhang and build_overhang_ht when build_has_tree_overhang is 1
# build %>% 
#   select(damage_binary, build_has_tree_overhang, build_perc_overhang, build_overhang_ht) %>%  
#   mutate(build_perc_overhang = build_perc_overhang*100) %>%
#     filter(build_has_tree_overhang == '1') %>% view()


#Summary tables on defensible space - descriptive summary for pub


tab_labs <- 
  read_csv(paste0(getwd(), '/data/Table_Deviance_Explained_2022-03-08.csv'))

tab_labs %>%  
  filter(Table2 == 1) %>%
  tidylog::select('Variable name', Type) %>% 
  mutate(Type = fct_recode(factor(Type),
                              'Defensible Space'     = 'DEF',
                              'Landscape Attributes' = 'LAND')) %>% 
  slice(1,14,5,2:4,15,6:13,16:48) -> vars_to_include_tbl_2 #using slice to do custom reorder of variables for table presentation
# FIXME slice is really dangerous here - just be careful and double, triple check you got what you wanted
# #Ah, is there function you recommend better? It doesn't drop any, just rearranges their order.
# It works, so don't change it. In a spreadsheet an order field could be added and then arrange() could be used to sort the table by that column. Or in the code it could be made an #ordered factor manually.. if anything causes that file to change its order (items are added or dropped) then the slice with index numbers are all off. If there are no changes, then #its not a problem. I just flagged an instance to be cautious about on the heals of re-doing the deviance table where items were added and dropped and the order was altered for the #PDP/ICE graphs..


#BUILD Table 1 with theme - type = defensible space 
vars_to_include_tbl_2 %>% 
  filter(Type == 'Defensible Space') %>% 
  tidylog::select('Variable name') -> vars_to_include_tbl_2DEF

tbl_DEF <- build %>% 
  select(damage_cat, any_of(vars_to_include_tbl_2DEF$`Variable name`)) %>%  
  tbl_summary (by = damage_cat, type = list(where(is.numeric) ~ "continuous")) %>%  #Dexter, I think this is forcing build_p_water10 to be continuous and looks like output is still the same  
  add_overall() %>%  
  add_p()%>%  
  as_gt()

#BUILD Table 2 with theme - type = landscape
vars_to_include_tbl_2 %>% 
  filter(Type == 'Landscape Attributes') %>% 
  tidylog::select('Variable name') -> vars_to_include_tbl_2LAND

tbl_LAND <- build %>% 
  select(damage_cat, any_of(vars_to_include_tbl_2LAND$`Variable name`)) %>%  
  tbl_summary(by = damage_cat) %>%  
  add_overall() %>%  
  add_p() %>%  
  as_gt()

tbl_desc <- tbl_stack(list(tbl_DEF, tbl_LAND), group_header = c("Defensible Space", "Landscape Attributes")) %>% 
             gt::tab_style(
              style = gt::cell_text(weight = "bold"),
              locations = gt::cells_row_groups(groups = everything()))


#Dexter, this is still rather long - do you think this will work for paper? Should we consider placing the tables side by side or other formatting?
# save out a big stacked table
#tbl_desc  %>%  
#  gt::gtsave(paste0(getwd(), '/figures/Table_Descript_' , Sys.Date(), '.png'))
#save out individual tables
tbl_LAND %>%  
  gt::gtsave(paste0(getwd(), '/figures/Table_Descript_Land' , Sys.Date(), '.png'))
tbl_DEF %>%  
  gt::gtsave(paste0(getwd(), '/figures/Table_Descript_Def' , Sys.Date(), '.png'))


```


## 3 correlations
```{r}

# TODO check out error message.
build %>%
  tidylog::select_if(is_double) %>% # just numerically-encoded variables
  tab_corr(.
           , triangle = 'lower'
           # , file = paste0(getwd(), '/output_data/correlations_',
           #                 gsub('[[:punct:]]', '_', Sys.time()), '.html')
           )


# find large correlations
build %>% 
  tidylog::select_if(is_double) %>% 
  cor() %>% 
  data.frame() %>% 
  rownames_to_column() %>% 
  as_tibble() %>%
  pivot_longer(-rowname) %>% 
  arrange(desc(value)) -> cors_tibble

#select any pairs where correlation coefficient greater .7
#all the pairs with corr greater than .7 are either duplicate measures of vegetation at differences or parcel chars
cors_tibble %>% 
  filter(value > .7 & value < 1) %>% 
    View()


#Older thoughts on correlations
#near_dest and near_exp highly correlated, not surprising
 #elevation measures are highly correlated, not surprising
 #elevation of a building is related to land cover (higher elev has less road and building around but more veg- relationships differ w 10 vs 200 buffer)
 #build_min_dist_shrub correlated w elevation - wouldn't have thought that.
 #build_dist_angle-from near tool, angle to nearest building
 #tree overhang measures and 10 m are all pretty related
 #none of these are very strong corrs - but building age is related to landscape characteristics - older buildings are higher elev, farther from road, closer to shrub,have more tree overhang and more tree around building (less grass, less imperv). Older buildings are on parcels that have more tree and pervious cover, but less grass & building cover


```


## 4 missing values
```{r}
build %>% map(., ~sum(is.na(.))) # TODO drop missings fit, models and see if variables with missing values 'matter' in the prediction of burn

build %>%
  map(., ~sum(is.na(.))) %>%
  map_dfc(., ~.x) %>% 
  t() %>% 
  View()
```



# 5 hists land cover & draft for pub
```{r}

build %>% 
  #st_drop_geometry() %>% 
  tidylog::select(ID_Build, contains('build_p_')) %>% 
  pivot_longer(-ID_Build) %>% 
  mutate(#buff_dist = as.numeric(str_remove_all(name, '\\D')),
         var = str_remove(name, 'build_p_')) %>% 
  separate(var, into = c('var', 'buff_dist'), sep = '_', convert = TRUE) %>% 
  ggplot(aes(x = value)) + 
  # geom_density() + 
  geom_histogram() +
  #facet_wrap(~var + buff_dist, ncol = 4) +
  facet_grid(buff_dist ~ var) +
  theme_bw() + 
  # ggsave(file = paste0(getwd(), '/figures/donut_buff_landcover_',
  #                   gsub('[[:punct:]]', '_', Sys.time()), '.png')) +
  NULL

#work on for publication, only 300 m
# 4/6/2022
#if we keep, reorder factors, and tweak formatting


# (
#   ggp4 <- build %>% 
#     tidylog::select(ID_Build, contains('build_p_')) %>% 
#     pivot_longer(-ID_Build) %>% 
#     mutate(#buff_dist = as.numeric(str_remove_all(name, '\\D')),
#            var = str_remove(name, 'build_p_')) %>% 
#     separate(var, into = c('var', 'buff_dist'), sep = '_', convert = TRUE) %>%  #if we keep, reorder factors, and tweak formatting
#     filter(buff_dist == 300 & var != 'water') %>% 
#     mutate(`Land Cover` = factor(str_to_title(ifelse(var == 'otherpaved', 'other paved', var)), ordered = TRUE,
#            levels = c('Tree', 'Shrub', 'Grass', 'Soil', 'Building', 'Road', 'Other Paved'))) %>%  
#     # mutate(holc_grade = factor(holc_grade, levels = LETTERS[1:4], ordered = TRUE)) %>% 
#     ggplot(aes(x = value, fill = `Land Cover`)) +  
#     geom_histogram(bins = 30) +
#     scale_fill_manual(
#       values = c(
#         '#0b5304', # Tree 
#         '#ffff0c', # Shrub
#         '#b4ff8f', # Grass
#         '#6b3f02', # Soil
#         # '#0b00fe', # Water
#         '#f40008', # Building
#         '#010101', # Road
#         '#908e92' # Other Paved'
#         )
#       ) + 
#     facet_wrap(~`Land Cover`, ncol = 4) +
#     labs(title = "Histogram of land cover 300 ft around building") + 
#     theme_bw(16) + 
#     theme(legend.position = c(.885, .25)) + 
#     scale_y_continuous(expand = c(0, 0)) +
#     scale_x_continuous(expand = c(0, 0)) +
#     NULL
#   )

# ggsave(file = paste0(getwd(), '/figures/buff_landcover_300_',
#                      gsub('[[:punct:]]', '_', Sys.time()), '.png')
#        , height = 4*2, width = 5*2
#        # , dpi = 100
#        )


# Average distance to road
# average building density
# distance to destrooyed building
# building area

# ggp1 <- build %>% 
#   mutate(`Average Elevation of each Building (100 meter buffer)` = build_Mean_elev_100m,
#          `Damage Category` = damage_cat) %>%   
#   ggplot(aes(`Average Elevation of each Building (100 meter buffer)`, fill = `Damage Category`)) + 
#   geom_density(alpha = .5) + 
#   scale_x_continuous(expand = c(0, 0)) +
#   scale_y_continuous(expand = c(0, 0), limits = c(0, 0.0021)) +
#   theme_bw(16) + 
#   theme(legend.position = c(.7, .7)) + 
#   NULL


(ggp1 <- build %>% 
  mutate(`Average Distance to Road for each Building` = build_Mean_distroad,
         `Damage Category` = damage_cat) %>%   
  ggplot(aes(`Average Distance to Road for each Building`, fill = `Damage Category`)) + 
  geom_density(alpha = .5) + 
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.0011)
                     ) +
  theme_bw(16) + 
  theme(legend.position = c(.7, .7)) + 
  NULL)

(ggp2 <- build %>% 
  mutate(`Average Building Density` = build_Mean_builddens,
         `Damage Category` = damage_cat) %>%   
  ggplot(aes(`Average Building Density`, fill = `Damage Category`)) + 
  geom_density(alpha = .5) + 
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.6)) +
  theme_bw(16) + 
  theme(legend.position = c(.7, .7)) + 
  NULL)



(ggp3 <- build %>% 
  mutate(`Distance to Destroyed Building (log scale)` = build_near_dest,
         `Damage Category` = damage_cat) %>%   
  ggplot(aes(`Distance to Destroyed Building (log scale)`, fill = `Damage Category`)) + 
  geom_density(alpha = .5) + 
  # scale_x_continuous(expand = c(0, 0)) +
  scale_x_log10(labels = scales::label_comma()) + # thousands
  scale_y_continuous(expand = c(0, 0), limits = c(0, 0.9)
                     ) +
  theme_bw(16) + 
  theme(legend.position = c(.25, .7)) + 
  NULL)


# (ggp4 <- build %>% 
#   mutate(`Building Area (log scale)` = build_area,
#          `Damage Category` = damage_cat) %>%   
#   ggplot(aes(`Building Area (log scale)`, fill = `Damage Category`)) + 
#   geom_density(alpha = .5) + 
#   # scale_x_continuous(expand = c(0, 0)) +
#   # scale_x_log10(labels = scales::label_number(suffix = " K", scale = 1e-6)) + # thousands
#   scale_x_log10(labels = scales::label_comma()) + 
#   # scale_y_continuous(expand = c(0, 0), limits = c(0, 0.9)
#   #                     ) +
#   theme_bw(16) + 
#   theme(legend.position = c(.25, .7)) + 
#   NULL)

#replaced 4th figure with percent_built given that higher deviance
(ggp4 <- build %>% 
  mutate(`Percent Built (Parcel)` = parcel_Build_P,
         `Damage Category` = damage_cat) %>%   
  ggplot(aes(`Percent Built (Parcel)`, fill = `Damage Category`)) + 
  geom_density(alpha = .5) + 
   scale_x_continuous(expand = c(0, 0)) +
  # scale_x_log10(labels = scales::label_number(suffix = " K", scale = 1e-6)) + # thousands
  # scale_x_log10(labels = scales::label_comma()) + 
  # scale_y_continuous(expand = c(0, 0), limits = c(0, 0.9)
  #                     ) +
  theme_bw(16) + 
  theme(legend.position = c(.7, .7)) + 
  NULL)


# ggp1<- build %>% ggplot(aes(build_Mean_elev_100m)) + geom_histogram(binwidth = 25) + theme_classic()
# ggp2<- build %>% ggplot(aes(build_Mean_distroad)) + geom_histogram(binwidth = 20)  + theme_classic()
# ggp3<- build %>% ggplot(aes(build_Mean_builddens)) + geom_histogram(binwidth = .1) + theme_classic()

ggp_all <- (ggp1 + ggp2) / (ggp3 + ggp4) +    # Create grid of plots with title
   plot_annotation(tag_levels = 'I')
  # plot_annotation(title = "Descriptives for publication") & 
  # theme(plot.title = element_text(hjust = 0.5))
ggp_all   


ggsave(file = paste0(getwd(), '/figures/Fig_2_descriptives_',
                     gsub('[[:punct:]]', '_', Sys.time()), '.png')
       , height = 6.5*2.5, width = 6.5*2.5
       # , dpi = 100
       )


```


## 6 year built
```{r}
build %>%   #Dexter, this & below don't run for me, FWIW
  tidylog::select(starts_with("parcel_Effective"),
         # starts_with("parcel_YearBuilt"),
         parcel_year_built) %>% map(., ~sum(is.na(.)))

# how many of these 
build %>%
  filter(parcel_Roll_ImpValue == 0 &
           parcel_Roll_HomeOwnersExemp == 0 &
           parcel_Build_P == 0) %>% # year built should be zero for these
  glimpse()

# where are these NA's?
build %>% filter(is.na(parcel_year_built)) #%>% mapview()
build %>% filter(parcel_year_built == 0) #%>% mapview()

summary(build$parcel_year_built)

build %>%
  ggplot(aes(parcel_year_built)) +
  geom_histogram() -> build_year_built_hist

build %>%
  filter(parcel_year_built > 0) %>% 
  ggplot(aes(parcel_year_built)) +
  geom_histogram() + 
  ggtitle('zeros removed') -> build_year_built_hist_no_zero

build_year_built_hist + build_year_built_hist_no_zero

# ggsave(file = paste0(getwd(), '/figures/effective_yearRecent_',
#                     gsub('[[:punct:]]', '_', Sys.time()), '.png'))
```


## 7 land use
```{r}

(build %>% tabyl(parcel_UseDescription) %>% as_tibble() -> lu_counts)


lu_counts %>%
  ggplot(aes(n, reorder(parcel_UseDescription, -n))) + 
  geom_col() + 
  theme_bw() + 
  NULL
  

```


## 8 boxplots w/predictors
```{r}

#  
# DINS work
#DINS has 12% survived only
table(build$damage_binary,build$build_DINS)

#roof siding veg - these look like interesting relationships
par(mfrow=c(1,3))
bargraph.CI(build$build_ROOFCONSTR,build$damage_binary,main="Roof",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_EXTERIORSI,build$damage_binary,main="Ext Siding",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_VEGCLEARAN,build$damage_binary,main="Veg clear",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))

par(mfrow=c(3,3))
bargraph.CI(build$build_FENCEATTAC,build$damage_binary,main="Fence",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_DECKPORCHO,build$damage_binary,main="Deck/Porch Ongrade",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_DECKPORCHE,build$damage_binary,main="Deck/Porch Elev",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_ROOFCONSTR,build$damage_binary,main="Roof",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_PROPANETAN,build$damage_binary,main="Propane",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_WINDOWPANE,build$damage_binary,main="Window",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_EAVES,build$damage_binary,main="Eaves",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1))
bargraph.CI(build$build_VENTSCREEN,build$damage_binary,main="Ventscreen",ylab="P(Loss)",xlab="",las=2,ylim=c(0,1)) 
  

box_plot_dat <- build %>%
  dplyr::select(damage_binary | where(is.double)) %>% 
  dplyr::select(c(damage_binary:build_near_exp)) %>%  #this might need to be revised if build variables change
  data.frame()
 
# 
# for(i in 2:ncol(box_plot_dat)){
#   print(names(box_plot_dat)[i])
#   png(file = paste0(getwd(), '/figures/boxplot_', names(box_plot_dat)[i], '_',
#                     gsub('[[:punct:]]', '_', Sys.time()), '.png'))
#   boxplot(box_plot_dat[,i] ~ box_plot_dat$damage_binary, main = names(box_plot_dat)[i])
#   dev.off()
# }

# renters vs. owners -doesn't seem to make a difference in outcome #Roll_HomeOwnersExemp==0 are renters, 5600 & 7000 are owners; 
# filter first by parcel_UseType=Residential

build %>%
  tidylog::filter(parcel_UseType=='Residential')  %>%
    tabyl(damage_binary,parcel_Roll_HomeOwnersExemp)%>%
      adorn_percentages() 


# summary(lm(damage_binary ~ build_near_dest, build))
# summary(lm(damage_binary ~ build_near_exp, build))




```


## 9 univariate models to update Table_Deviance_Explained_2022-03-08.csv (now that data have been filtered)
```{r}


(table1 <- list(names(build)) %>% #created a list of predictors
  data.frame() %>%
  mutate(dev2 = 0, n2 = 0) %>%
  rename(upvar = "c..damage_cat....damage_severity....build_area....build_DECKPORCHO...") %>%
  data.frame())

# add a binary outcome back in for glms
build <- build %>%  
  mutate(damage_binary = ifelse(damage_cat == 'Destroyed', 1, 0))

# 2x check
build %>%  tabyl(damage_binary, damage_cat)
table(build$damage_binary, build$damage_cat)

# # repurposed from Owne Price
 dat.model <- data.frame(y = build$damage_binary, x = 0)
#
i<-0
for (varname in table1$upvar) {
  i<-i+1
  if (varname %in% colnames(build)) {
    dat.model$x <- build[, varname]
    mod <- glm(y ~ x, data = dat.model, family = binomial())
  } else {
    warning(varname, " not found in build_a", immediate. = TRUE)
    mod <- NULL
  }

  if (!is.null(mod)) {
    table1$n2[i] <- nrow(build) - sum(is.na(dat.model$x))
    table1$dev2[i] <- 100 * (mod$null.deviance - mod$deviance) / mod$null.deviance
  }
}


# TODO Miranda, are these warnings a problem?
# read in variable descriptions
(tab_labs <- readxl::read_xlsx('data/Data LA Study 20220209.xlsx') %>%
  #mutate(Type = # turned this off bc longer attributes don't fit in table 
  #         case_when(
  #             Type == 'CON' ~ 'Construction'
  #           , Type == 'DEF' ~ 'Defensible Space'
  #           , Type == 'LAND'~ 'Landscape Attributes'
  #            , Type == 'TOPO'~ 'Topography'
  #           , Type == 'EXP' ~ 'Exposure'
   #          , TRUE ~ 'na')) %>%
  left_join(.
            , table1 %>% filter(upvar != 'damage_binary' & upvar!= 'build_DINS')
            , by = c(`Variable name` = 'upvar')) %>%
  tidylog::select(Type
                  , `Variable name`
                  , Alias # added this
                  , Deviance = dev2
                  , n = n2
                  , Scale
                  , Source
                  ) %>%
#     arrange(desc(Deviance))%>%
#  arrange(Type, desc(Deviance)) %>%
  mutate_if(is.double, round, 3))
#
# export
# redone June 13, 2022
  tab_labs %>%
    drop_na()%>%
   write_csv(., paste0(getwd(), '/data/Table_Deviance_Explained_', Sys.Date(), '.csv'))


#reading back in deviance explained
(tab_labs <- 
  read_csv(paste0(getwd(), '/data/Table_Deviance_Explained_2022-06-13.csv'))) 



```





```{r, citations}
lapply(packs, citation)
```


Last knit on `r format(Sys.time())`


```{r}
system.time(save.image(file = paste0('saved_sessions/wui_r_desc_eda_', gsub('[[:punct:]]', '-', Sys.time()), '.RData')))
```

