---
title: "03_fit_models"
author: "Dexter H. Locke, PhD"
date: "`r format(Sys.time())`"
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This assumes "02_Woosley_combine_data.Rmd" was run


TODO write out the 'final' dataset and read it back in here.


## 0 set up: load libraries, custom functions, set defaults
```{r}
# load libraries
# packages we'll be using
packs <- c('tidyverse'        # a must have!
           , 'tidylog'        # makes things very verbose for 2x checking 
           , 'magrittr'       # all of the pipes
           , 'janitor'        # cleans things up
           , 'sf'             # simple features
           , 'mapview'        # quick webmaps for zoom/pan viz
           #'tidycensus',     # access to Census data in a tidy way
           #'party',          # random forests
           , 'modEvA'         # contains D-squared function
           , 'beepr'          # makes noises
           , 'psych'          # describe is very useful for descriptive statistics
           , 'sjPlot')        # useful plotting and regression support

# check for all of the libraries
if (length(setdiff(packs, rownames(installed.packages()))) > 0) {
  install.packages(setdiff(packs, rownames(installed.packages())))  
}

lapply(packs, library, character.only = TRUE)
```




## 1 fit models
### A a little prep
```{r}
# TODO handel the NA's better than dropping 11%

# minor prep for binary 
build_bin <- build %>% 
  st_drop_geometry() %>% 
  select(damage_binary, build_Mean_elev_30m : build_Mean_distall_road,
         build_NEAR_DIST, build_NEAR_ANGLE,
         build_dist_to_build_ft : build_p_shrub_300,
         parcel_UseType: parcel_Imperv_P,
         parcel_recent) %>% 
  filter(parcel_recent > 0) %>% 
  drop_na() %>% 
  data.frame #%>% glimpse

# check for NA
map(build_bin, ~sum(is.na(.))) # check for NA's

build_bin %>% filter(parcel_recent == 0) %>% dim()

```




### B logistic regression
#### vegetation
```{r}
# build_bin_sel <- build_bin %>% select(damage_binary, 
#                                       build_treecan10 : build_shrub_300)
# 
veg_log_mods <- build_bin %>%
  nest() %>%
  mutate(log_build_p_tree_10 = map(., ~glm(damage_binary ~ build_p_tree_10, family = 'binomial', data = data.frame(.))),
         log_build_p_tree_100= map(., ~glm(damage_binary ~ build_p_tree_100,family = 'binomial', data = data.frame(.))),
         log_build_p_tree_200= map(., ~glm(damage_binary ~ build_p_tree_200,family = 'binomial', data = data.frame(.))),
         log_build_p_tree_300= map(., ~glm(damage_binary ~ build_p_tree_300,family = 'binomial', data = data.frame(.))),

         log_build_p_shrub_10 = map(., ~glm(damage_binary ~ build_p_shrub_10, family = 'binomial', data = data.frame(.))),
         log_build_p_shrub_100= map(., ~glm(damage_binary ~ build_p_shrub_100,family = 'binomial', data = data.frame(.))),
         log_build_p_shrub_200= map(., ~glm(damage_binary ~ build_p_shrub_200,family = 'binomial', data = data.frame(.))),
         log_build_p_shrub_300= map(., ~glm(damage_binary ~ build_p_shrub_300,family = 'binomial', data = data.frame(.))),

         log_build_p_grass_10 = map(., ~glm(damage_binary ~ build_p_grass_10, family = 'binomial', data = data.frame(.))),
         log_build_p_grass_100= map(., ~glm(damage_binary ~ build_p_grass_100,family = 'binomial', data = data.frame(.))),
         log_build_p_grass_200= map(., ~glm(damage_binary ~ build_p_grass_200,family = 'binomial', data = data.frame(.))),
         log_build_p_grass_300= map(., ~glm(damage_binary ~ build_p_grass_300,family = 'binomial', data = data.frame(.)))) %>%
  select(-data) %>% 
  rowid_to_column() %>% 
  pivot_longer(-rowid, names_to = 'model_name', values_to = 'model') %>% 
  select(-rowid) %>% 
  mutate(#smry = map(model, summary),
         dsqr = map(model, Dsquared),
         AIC = map(model, AIC),
         r2 = map(model, performance::r2))
  

veg_log_mods %>% select(model_name, dsqr, AIC, r2) %>% 
  unnest(dsqr, AIC, r2) %>% unnest(r2)


veg_log_mods %>% select(model_name) %>% toString() %>% 
  str_replace_all(., '\", \"', ',') %>% 
  str_sub(4, -4) -> test


performance::compare_performance(pull(veg_log_mods$model))



summary(veg_log_mods$model[[1]])

# # OLD
# # 
# # build_bin %>% 
# #   mutate(log_mod_build_p_tree_10 = map(., ~glm(damage_binary ~ build_p_tree_10, data = data.frame(.))))
# 
# log_build_p_tree_10  <- glm(damage_binary ~ build_p_tree_10, data = build_bin, family = 'binomial')
# log_build_p_tree_100 <- glm(damage_binary ~ build_p_tree_100,data = build_bin, family = 'binomial')
# log_build_p_tree_200 <- glm(damage_binary ~ build_p_tree_200,data = build_bin, family = 'binomial')
# log_build_p_tree_300 <- glm(damage_binary ~ build_p_tree_300,data = build_bin, family = 'binomial')
# 
# # performance::compare_performance(
# #   log_build_treecan10, log_build_treecan100, log_build_treecan200, log_build_treecan300,
# #   rank = TRUE)
# 
# # performance::check_model(log_build_treecan100)
# #tab_model(log_build_treecan100)
# # tab_model(log_build_treecan10, log_build_treecan100, log_build_treecan200, log_build_treecan300,
# #           show.aic = TRUE, show.dev = TRUE)
# 
# # https://rdrr.io/rforge/modEvA/man/Dsquared.html
# modEvA::Dsquared(log_build_p_tree_10)
# modEvA::Dsquared(log_build_p_tree_100) # suggests 100
# modEvA::Dsquared(log_build_p_tree_200)
# modEvA::Dsquared(log_build_p_tree_300) 
# 
# # GRASS
# log_build_grass10  <- glm(damage_binary ~ build_grass10, data = build_bin, family = 'binomial')
# log_build_grass100 <- glm(damage_binary ~ build_grass_100,data = build_bin, family = 'binomial')
# log_build_grass200 <- glm(damage_binary ~ build_grass_200,data = build_bin, family = 'binomial')
# log_build_grass300 <- glm(damage_binary ~ build_grass_300,data = build_bin, family = 'binomial')
# 
# performance::compare_performance(
#   log_build_grass10, log_build_grass100, log_build_grass200, log_build_grass300,
#   rank = TRUE)
# 
# #performance::check_model(log_build_grass300)
# #tab_model(log_build_grass300)
# 
# modEvA::Dsquared(log_build_grass10)
# modEvA::Dsquared(log_build_grass100)
# modEvA::Dsquared(log_build_grass200)
# modEvA::Dsquared(log_build_grass300) # suggests 300
# 
# 
# # SHRUB
# log_build_shrub10  <- glm(damage_binary ~ build_shrub_10, data = build_bin, family = 'binomial')
# log_build_shrub100 <- glm(damage_binary ~ build_shrub_100,data = build_bin, family = 'binomial')
# log_build_shrub200 <- glm(damage_binary ~ build_shrub_200,data = build_bin, family = 'binomial')
# log_build_shrub300 <- glm(damage_binary ~ build_shrub_300,data = build_bin, family = 'binomial')
# 
# # performance::compare_performance(
# #   log_build_shrub10, log_build_shrub100, log_build_shrub200, log_build_shrub300,
# #   rank = TRUE)
# # 
# # performance::check_model(log_build_shrub300)
# 
# modEvA::Dsquared(log_build_shrub10)
# modEvA::Dsquared(log_build_shrub100)
# modEvA::Dsquared(log_build_shrub200)
# modEvA::Dsquared(log_build_shrub300) # suggests 300
# 
# # tab_model(log_build_treecan100, log_build_grass300, log_build_shrub300,
# #          file = paste0(getwd(),
# #                        '/output_data/veg_logistic_reg_',
# #                        gsub('[[:punct:]]', '_', Sys.time()), '.html'))
```



#### other land covers
```{r}
# SOIL
log_build_soil10  <- glm(damage_binary ~ build_soil_10, data = build_bin, family = 'binomial')
log_build_soil100 <- glm(damage_binary ~ build_soil_100,data = build_bin, family = 'binomial')
log_build_soil200 <- glm(damage_binary ~ build_soil_200,data = build_bin, family = 'binomial')
log_build_soil300 <- glm(damage_binary ~ build_soil_300,data = build_bin, family = 'binomial')

# https://rdrr.io/rforge/modEvA/man/Dsquared.html
modEvA::Dsquared(log_build_soil10)
modEvA::Dsquared(log_build_soil100)
modEvA::Dsquared(log_build_soil200)
modEvA::Dsquared(log_build_soil300) # suggests 300

# WATER
log_build_water10  <- glm(damage_binary ~ build_water_10, data = build_bin, family = 'binomial')
log_build_water100 <- glm(damage_binary ~ build_water_100,data = build_bin, family = 'binomial')
log_build_water200 <- glm(damage_binary ~ build_water_200,data = build_bin, family = 'binomial')
log_build_water300 <- glm(damage_binary ~ build_water_300,data = build_bin, family = 'binomial')

# https://rdrr.io/rforge/modEvA/man/Dsquared.html
modEvA::Dsquared(log_build_water10)
modEvA::Dsquared(log_build_water100)
modEvA::Dsquared(log_build_water200)
modEvA::Dsquared(log_build_water300) # suggests 300


# BUILD
log_build_build10  <- glm(damage_binary ~ build_build_10, data = build_bin, family = 'binomial')
log_build_build100 <- glm(damage_binary ~ build_build_100,data = build_bin, family = 'binomial')
log_build_build200 <- glm(damage_binary ~ build_build_200,data = build_bin, family = 'binomial')
log_build_build300 <- glm(damage_binary ~ build_build_300,data = build_bin, family = 'binomial')

# https://rdrr.io/rforge/modEvA/man/Dsquared.html
modEvA::Dsquared(log_build_build10)
modEvA::Dsquared(log_build_build100)
modEvA::Dsquared(log_build_build200)
modEvA::Dsquared(log_build_build300) # suggests 300




# OTHER IMP
log_build_oth_imp10  <- glm(damage_binary ~ build_oth_imp_10, data = build_bin, family = 'binomial')
log_build_oth_imp100 <- glm(damage_binary ~ build_oth_imp_100,data = build_bin, family = 'binomial')
log_build_oth_imp200 <- glm(damage_binary ~ build_oth_imp_200,data = build_bin, family = 'binomial')
log_build_oth_imp300 <- glm(damage_binary ~ build_oth_imp_300,data = build_bin, family = 'binomial')

# https://rdrr.io/rforge/modEvA/man/Dsquared.html
modEvA::Dsquared(log_build_oth_imp10)
modEvA::Dsquared(log_build_oth_imp100)
modEvA::Dsquared(log_build_oth_imp200)
modEvA::Dsquared(log_build_oth_imp300) # suggests 300



# ROAD
log_build_road10  <- glm(damage_binary ~ build_road_10, data = build_bin, family = 'binomial')
log_build_road100 <- glm(damage_binary ~ build_road_100,data = build_bin, family = 'binomial')
log_build_road200 <- glm(damage_binary ~ build_road_200,data = build_bin, family = 'binomial')
log_build_road300 <- glm(damage_binary ~ build_road_300,data = build_bin, family = 'binomial')

# https://rdrr.io/rforge/modEvA/man/Dsquared.html
modEvA::Dsquared(log_build_road10)
modEvA::Dsquared(log_build_road100)
modEvA::Dsquared(log_build_road200)
modEvA::Dsquared(log_build_road300) # suggests 300


```


#### 'landscape position'
```{r}

log_build_Mean_elev_30m  <- glm(damage_binary ~ build_Mean_elev_30m,
                                data = build_bin, family = 'binomial')

log_build_Mean_elev_100m <- glm(damage_binary ~ build_Mean_elev_100m,
                                data = build_bin, family = 'binomial')

modEvA::Dsquared(log_build_Mean_elev_30m) # suggests 30m
modEvA::Dsquared(log_build_Mean_elev_100m)


log_build_Mean_slope_30m_DEM <- glm(damage_binary ~ build_Mean_slope_30m_DEM,
                                   data = build_bin, family = 'binomial')

log_build_Mean_slope_100m_DEM <- glm(damage_binary ~ build_Mean_slope_100m_DEM,
                              data = build_bin, family = 'binomial')

modEvA::Dsquared(log_build_Mean_slope_30m_DEM) 
modEvA::Dsquared(log_build_Mean_slope_100m_DEM)# suggests 100m


log_build_Mean_aspect_30m_DEM <- glm(damage_binary ~ build_Mean_aspect_30m_DEM,
                                   data = build_bin, family = 'binomial')

log_build_Mean_aspect_100m_DEM <- glm(damage_binary ~ build_Mean_aspect_100m_DEM,
                              data = build_bin, family = 'binomial')

modEvA::Dsquared(log_build_Mean_aspect_30m_DEM)
modEvA::Dsquared(log_build_Mean_aspect_100m_DEM) # suggests 100m


log_build_Mean_distroad <- glm(damage_binary ~ build_Mean_distroad,
                              data = build_bin, family = 'binomial')

log_build_Mean_builddens <- glm(damage_binary ~ build_Mean_builddens,
                              data = build_bin, family = 'binomial')

log_build_Mean_distall_road <- glm(damage_binary ~ build_Mean_distall_road,
                              data = build_bin, family = 'binomial')



# performance::compare_performance(
# log_build_Meanelev_30m,
# log_build_Meanelev_100m, 
# 
# log_build_Meanslope_30m_DEM, 
# log_build_Meanslope_100m_DEM, 
# 
# 
# log_build_Meanaspect_30m_DEM,
# log_build_Meanaspect_100m_DEM, 
# 
# log_build_Meandistroad,
# log_build_Meanbuilddens, 
# 
# 
# log_build_Meandistall_road, rank = TRUE)
# 
# 
# tab_model(log_build_Meanelev_30m,
#           log_build_Meanelev_100m, 
# 
#           log_build_Meanslope_30m_DEM, 
#           log_build_Meanslope_100m_DEM, 
#           
#           
#           log_build_Meanaspect_30m_DEM,
#           log_build_Meanaspect_100m_DEM, 
#           
#           log_build_Meandistroad,
#           log_build_Meanbuilddens, 
#           
#           log_build_Meandistall_road, show.aic = TRUE)
#  
# 
# 
# tab_model(log_build_Meanelev_30m,
#           log_build_Meanelev_100m, 
# 
#           log_build_Meanslope_30m_DEM, 
#           log_build_Meanslope_100m_DEM, 
#           
#           
#           log_build_Meanaspect_30m_DEM,
#           log_build_Meanaspect_100m_DEM, 
#           
#           log_build_Meandistroad,
#           log_build_Meanbuilddens, 
#           
#           log_build_Meandistall_road,
#          file = paste0(getwd(),
#                        '/output_data/landscape_logistic_reg_',
#                        gsub('[[:punct:]]', '_', Sys.time()), '.html'))

# # a very bad model
# log_r_1 <- glm(damage_binary~., data = build_bin, family = 'binomial')
# summary(log_r_1)
# # plot_model(log_r_1, sort.est = TRUE, vline.color = 'black') %>% theme_bw(16)
# # tab_model(log_r_1, digits = 6)
# 
# ptm <- proc.time() # clock in
# log_r_step <- glm(damage_binary~., data = build_rforest_bin, family = binomial) %>% 
#   MASS::stepAIC(trace = FALSE)
# (proc.time() - ptm) / 60 # clock out, about 12 minutes
# beepr::beep()
# plot_model(log_r_step, sort.est = TRUE, vline.color = 'black') %>% theme_bw(16)
# 
# # logistic regression validation
# # http://www.sthda.com/english/articles/36-classification-methods-essentials/150-stepwise-logistic-regression-essentials-in-r/
# # Make predictions
# # probabilities <- log_r_1 %>% predict(test.data, type = "response")
# # predicted.classes <- ifelse(probabilities > 0.5, "pos", "neg")
# # # Model accuracy
# # mean(predicted.classes==test.data$diabetes)

```



#### what did we learn from these logisitc regressions?
```{r}

tab_model(log_build_treecan100, log_build_grass300, log_build_shrub300, # veg
          log_build_soil300, log_build_water300, log_build_build300, log_build_oth_imp300, log_build_road300,
          log_build_Meanelev_30m, log_build_Meanslope_100m_DEM, log_build_Meanaspect_100m_DEM,
          log_build_Meandistroad, log_build_Meanbuilddens, log_build_Meandistall_road)

build_bin %>% select(build_treecan100,
                     build_grass_300,
                     build_shrub_300,
                     build_soil_300,
                     build_water_300,
                     build_build_300,
                     build_oth_imp_300,
                     build_road_300,
                     build_Meanelev_30m,
                     build_Meanslope_100m_DEM,
                     build_Meanaspect_100m_DEM,
                     build_Meandistroad,
                     build_Meanbuilddens,
                     build_Meandistall_road) %>% corr.test() -> corrs
corrs$r
 
build_bin %>% select(build_treecan100,
                     build_grass_300,
                     build_shrub_300,
                     build_soil_300,
                     build_water_300,
                     build_build_300,
                     build_oth_imp_300,
                     build_road_300,
                     build_Meanelev_30m,
                     build_Meanslope_100m_DEM,
                     build_Meanaspect_100m_DEM,
                     build_Meandistroad,
                     build_Meanbuilddens,
                     build_Meandistall_road) %>%
  sjt.corr(.,
         corr.method = 'spearman',
         triangle = 'lower',
         p.numeric = TRUE) #   file = paste0(getwd(), '/output_data/tables/cbg_demo_corrs.html'))

# build_bin %>% 
#   widyr::pairwise_cor(build_treecan100,
#                      build_grass_300,
#                      build_shrub_300,
#                      build_soil_300,
#                      build_water_300,
#                      build_build_300,
#                      build_oth_imp_300,
#                      build_road_300,
#                      build_Meanelev_30m,
#                      build_Meanslope_100m_DEM,
#                      build_Meanaspect_100m_DEM,
#                      build_Meandistroad,
#                      build_Meanbuilddens,
#                      build_Meandistall_road, upper = FALSE)
# 
# 

```

#### maximal logistic models?
```{r}
build_bin_parsimony <- build_bin %>%
  select(damage_binary,
         build_treecan100, build_grass_300, build_shrub_300,
         build_soil_300, build_water_300, build_build_300, build_oth_imp_300, build_road_300,
         build_Meanelev_30m, build_Meanslope_100m_DEM, build_Meanaspect_100m_DEM,
         build_Meandistroad,
         build_Meanbuilddens, build_Meandistall_road) %>% 
  drop_na()
  
log_r_maximal <- glm(damage_binary~., data = build_bin_parsimony, family = binomial) 

log_r_step <- glm(damage_binary~., data = build_bin_parsimony, family = binomial) %>%
  MASS::stepAIC(trace = FALSE)

tab_model(log_r_maximal, log_r_step,
          show.aic = TRUE, show.r2 = TRUE)

modEvA::Dsquared(log_r_maximal)
modEvA::Dsquared(log_r_step)

performance::compare_performance(log_r_maximal, log_r_step)
```





### C fit Jeffrey Evan's worked example: randomForest
```{r}
# modeled after and adapted from this page
# from https://evansmurphy.wixsite.com/evansspatial/random-forest-sdm

# abbridged from J Evan's second chunk (chunk 1 accesses data)
library(randomForest)
library(rfUtilities)

b <- 1001                                     # Number of Bootstrap replicates
# snip
# chunks 3 and 4 import raster dadta and extract variables from raster to absence/present point locations
# snip

build_bin_parsimony

build_bin_parsimony %>% tabyl(damage_binary)

build_bin_parsimony %<>% mutate(damage_binary = as.factor(damage_binary)) %>% data.frame()# PAY ATTENTION HERE
build_bin_parsimony %>% glimpse


(cl <- multi.collinear(build_bin_parsimony[,2:ncol(build_bin_parsimony)], p = 0.05))

# tell us what's got to go!
# for(l in cl) {
#   cl.test <- build_bin_parsimony[,-which(names(build_bin_parsimony)==l)]
#   print(paste("Remove variable", l, sep=": "))
#   multi.collinear(cl.test, p=0.05) 
# }
# 
# 
# build_bin_parsimony <- build_bin_parsimony[,-which(names(build_bin_parsimony) %in% cl )] %>% 
#   data.frame()

# Chunk 8 makes depenent variable categorical (done). BUT it also checks for frequency of presense

# "We observe that the sample balance of presence locations is 33% thus, meeting the 1/3 rule for sample balance."

build_bin_parsimony %>% tabyl(damage_binary)
print('12% - is this a problem?!?!')

# model selection
# ( rf.model <- rf.modelSel(x=sdata@data[,3:ncol(sdata@data)], y=sdata@data[,"Present"], imp.scale="mir", ntree=b) )

ptm <- proc.time() # clock in
(rf.model <- rf.modelSel(x=build_bin_parsimony[,2:ncol(build_bin_parsimony)],
                         y=build_bin_parsimony[,"damage_binary"],
                         imp.scale="mir", ntree=b))
(proc.time() - ptm) / 60 # clock out, about 3 minutes
beepr::beep()


sel.vars <- rf.model$selvars

# OR, pick a model?
#sel.vars <- rf.model$parameters[[4]] # DECISION POINT

# run a model
ptm <- proc.time() # clock in
( rf.fit <- randomForest(y=build_bin_parsimony[,"damage_binary"], x=build_bin_parsimony[,sel.vars],
                         ntree=b,
                         importance=TRUE, norm.votes=TRUE, proximity=TRUE) )
(proc.time() - ptm) / 60 # clock out, about 3 minutes
beepr::beep()


# run a model with ALL PREDICTORS
ptm <- proc.time() # clock in
( rf.fit_all <- randomForest(y=build_bin_parsimony[,"damage_binary"],
                             x=build_bin_parsimony[,2:ncol(build_bin_parsimony)],
                         ntree=b,
                         importance=TRUE, norm.votes=TRUE, proximity=TRUE) )
(proc.time() - ptm) / 60 # clock out, about 4 minutes
beepr::beep()


ptm <- proc.time() # clock in
( imbal <- randomForestSRC::imbalanced(damage_binary~., data=build_bin_parsimony) )
(proc.time() - ptm) / 60 # clock out, about 3 minutes
beepr::beep()

# skipping chunks 13 and 14: predicted raster map.. doesn't really apply here.

# model fit!
rf.pred <- predict(rf.fit, build_bin_parsimony[,sel.vars], type="response")

rf.prob <- as.data.frame(predict(rf.fit, build_bin_parsimony[,sel.vars], type="prob"))

obs.pred <- data.frame(cbind(Observed=as.numeric(as.character(build_bin_parsimony[,"damage_binary"])),
                             PRED=as.numeric(as.character(rf.pred)), Prob1=rf.prob[,2],
                             Prob0=rf.prob[,1]) )

op <- (obs.pred$Observed == obs.pred$PRED)



( pcc <- (length(op[op == "TRUE"]) / length(op))*100 )



library(verification)

roc.plot(obs.pred[,"Observed"], obs.pred[,"Prob1"])


# model validation
ptm <- proc.time() # clock in
( rf.perm <- rf.significance(rf.fit, build_bin_parsimony[,sel.vars], nperm = 99, ntree = 1001) )
(proc.time() - ptm) / 60 # clock out, 59 minutes with 99 permutations
beepr::beep()

saveRDS(rf.perm, file = "output_data/rf.perm.rds")

# cross validation
ptm <- proc.time() # clock in
( rf.cv <- rf.crossValidation(rf.fit, build_bin_parsimony[,sel.vars], p=0.10, n=99, ntree=1001) )
(proc.time() - ptm) / 60 # clock out, about 143 minutes (2.38 hours) with 999 permutations
beepr::beep()

# so this model isn't very good

saveRDS(rf.cv, file = "output_data/rf.perm.rds")

# so the number of trees is probably over kill at 1000? 75 sufficient?
plot(rf.fit, main="Bootstrap Error Convergence")


# variable importance
p <- as.matrix(rf.fit$importance[,3])   
ord <- rev(order(p[,1], decreasing=TRUE)[1:dim(p)[1]]) 


png(file = paste0(getwd(), '/figures/var_imp', gsub('[[:punct:]]', '_', Sys.time()), '.png'))
dotchart(p[ord,1], main="Scaled Variable Importance", pch=19)  
dev.off()


p <- as.matrix(rf.fit_all$importance[,3])   
ord <- rev(order(p[,1], decreasing=TRUE)[1:dim(p)[1]]) 


png(file = paste0(getwd(), '/figures/var_imp_all', gsub('[[:punct:]]', '_', Sys.time()), '.png'))
dotchart(p[ord,1], main="Scaled Variable Importance", pch=19)  
dev.off()

(all_vars <- names(build_bin_parsimony))
par(mfrow=c(1,1))
for(i in all_vars[2:15]) {
  png(file = paste0(getwd(), '/figures/', i, '_',
                  gsub('[[:punct:]]', '_', Sys.time()), '.png'))
  rf.partial.prob(rf.fit_all, build_bin_parsimony[,all_vars], i, "1", smooth="spline", raw.line=FALSE)
  dev.off()
}  



# par(mfrow=c(2,2))
# for(i in sel.vars[1:4]) {
#   rf.partial.prob(rf.fit, build_rforest_cat[,sel.vars], i, "1", smooth="spline", raw.line=FALSE)
# }  


for(i in sel.vars) {
png(file = paste0(getwd(), '/figures/', i, '_',
                  gsub('[[:punct:]]', '_', Sys.time()), '.png'))
rf.partial.prob(rf.fit, build_bin_parsimony[,sel.vars], i, "1", smooth="spline", raw.line=FALSE)
dev.off()
  }  
beepr::beep()
```






### D R-part and cforest
```{r}

# recursive partitioning
rpart_1 <- rpart::rpart(damage_binary~.,data = build_bin)#, cp = 0.02)
summary(rpart_1)


png(file = paste0(getwd(), '/figures/rpart_', gsub('[[:punct:]]', '_', Sys.time()), '.png'))
rpart.plot::rpart.plot(rpart_1)
dev.off()
#labels(rpart_1)

# ptm <- proc.time() # clock in
# party_1 <- party::cforest(damage_binary~., data = build_bin)
# party_1_imp <- varimp(party_1); View(party_1_imp)
# (proc.time() - ptm) / 60 # clock out, about 6 minutes
# beepr::beep()
# 
# 
# cf <- party_1
# pt <- prettytree(cf@ensemble[[1]], names(cf@data@get("input"))) 
# nt <- new("BinaryTree") 
# nt@tree <- pt 
# nt@data <- cf@data 
# nt@responses <- cf@responses 

#plot(nt, type="simple")
```



#### i random forest readings

Thanks Sebastian Martinuzzi

https://evansmurphy.wixsite.com/evansspatial/random-forest-sdm

https://cran.r-project.org/web/packages/rfUtilities/index.html
(Utilities for Random Forest model selection, class balance correction, significance test, cross validation and partial dependency plots.)

https://www.rdocumentation.org/packages/randomForestSRC/versions/2.9.3/topics/imbalanced.rfsrc
(Imbalanced Two Class Problems)

Old, but important
https://statistics.berkeley.edu/sites/default/files/tech-reports/666.pdf

A review paper on "A survey on addressing high-class imbalance in big data"
https://link.springer.com/article/10.1186/s40537-018-0151-6

https://towardsdatascience.com/random-forest-in-r-f66adf80ec9

http://www.sthda.com/english/articles/36-classification-methods-essentials/150-stepwise-logistic-regression-essentials-in-r/#:~:text=The%20stepwise%20logistic%20regression%20can,ref(stepwise%2Dregression))

https://compstat-lmu.github.io/iml_methods_limitations/pdp.html

https://www.blopig.com/blog/2017/04/a-very-basic-introduction-to-random-forests-using-r/




```{r, citations}
lapply(packages, citation)
```


Last knit on `r format(Sys.time())`


```{r}
system.time(save.image(file = paste0('saved_sessions/wui_r_models_', gsub('[[:punct:]]', '-', Sys.time()), '.RData')))
```

